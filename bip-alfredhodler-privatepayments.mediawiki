<pre>
  BIP: ?
  Layer: Applications
  Title: Private Payments
  Author: Alfred Hodler <alfred_hodler@protonmail.com>
  Status: Draft
  Type: Informational
  Created: 2022-07-10
  License: MIT
</pre>

In the following text the BIP number is provisionally set to 999 for technical purposes until a BIP number is assigned.

==Abstract==

This BIP makes it possible for two parties to transact using addresses that only they can calculate. This is done using exclusively on-chain methods and in a manner that minimizes blockchain footprint. Receiving parties can share their payment codes publicly without a loss of privacy, as every sender will calculate a unique set of addresses for each payment code.

==Motivation==

A recipient that wishes to receive funds privately has several options. Each has tradeoffs in terms of chain analysis potential, recoverability, and wallet complexity.

'''Sharing a static address''' works well enough for one-time payments between two parties as long as the address is shared through a private channel. It does not work well for recurring payments because address reuse leads to a loss of privacy. Using this method for donations exacerbates the problem since the address will serve as a focal point for data collection and analysis. Wallets must not reissue the same address to multiple recipients.

'''Sharing a BIP32 extended public key''' works for recurring payments between two parties only. The same key cannot be shared to any other party without leaking the chain of payments. Furthermore, an extended public key does not say anything about address types and makes it possible for a sender to send to a script that a recipient cannot spend from. Alternate [https://github.com/satoshilabs/slips/blob/master/slip-0132.md version bytes] have been proposed to specify address types, but wallet adoption is limited.

'''Sharing a BIP380 descriptor containing an extended public key''' solves the address type issue from sharing a raw BIP32 extended key. The drawback is that descriptor support is not widespread, especially in mobile wallets.

'''Using a payment server''' works in the case of recipients that have the resources to set up and maintain a payment server that will generate a fresh address for each payment. These are usually businesses and the method is usually out of reach for the average user. The centralized server is vulnerable to takedown remotely and physically.

'''Sharing a BIP47 payment code''' addresses most of the above shortcomings. However, it introduces the following problems:

* The BIP uses a notification mechanism that relies on publicly known per-recipient notification addresses. If Alice wants to send funds to Bob, she has to use the same notification address that everyone else uses to notify Bob. If Alice is not careful with coin selection, i.e. ensuring that her notification UTXO is not linked to her, she will publicly expose herself as someone who is trying to send funds to Bob and their relationship becomes permanently visible on the blockchain.

* The BIP does not say anything about address types. Receiving wallets therefore have to watch all address types that can be created from a single public key. Even then, a sender could send to a script that a receipient cannot spend from.

==Method==

When Alice wants to start paying Bob in private, she imports his payment code into a compatible wallet. Her wallet extracts Bob's public key from the payment code and sends a notification transaction. If Bob finds a notification transaction addressed to himself, he imports Alice's public key contained therein and stores it. Bob then performs ECDH using Alice's public key and his own private key in order to calculate a common set of addresses to watch. Alice calculates the same set of addresses on her end and uses them to send coins to Bob. If Alice engages in coin control, both the initial notification transaction and subsequent payment transactions cannot be attributed to either party. Even if Alice uses coins that are already associated with her, chain analysis will identify her as a sender but Bob's privacy will remain entirely preserved.

==Specification==

===Definitions===

* Alice: sender
* Bob: recipient
* Payment code: static string that Bob generates and shares with others so that he can receive payments
* ''P'': public key contained in Bob's payment code
* ''p'': private key associated with Bob's public key ''P''
* ''N'': extended public key used by Alice to derive child keys for each Bob she wants to transact with
* ''n'': private key associated with Alice's public key ''N''
* ''x'': Alice's secret recipient index, unique for each Bob
* ''N<sub>x</sub>'': child public key derived from ''N'' at index ''x'' (non-hardened)
* ''n<sub>x</sub>'': private key associated with ''N<sub>x</sub>''
* ''c'': Alice's transaction count toward Bob
* ''P<sub>c</sub>'': Bob's public key at index ''c''
* ''p<sub>c</sub>'': Bob's private key at index ''c''
* ''A<sub>c</sub>'': Bob's receive address at index ''c''
* ''H'': SHA256 hash function
* ''*'': EC multiplication
* ''+'': EC addition
* ''|'': string concatenation

===Public Key Derivation Path===

The derivation path for this BIP follows BIP44. The following BIP32 path levels are defined:

<code>
m / purpose' / coin_type' / account'
</code>

<code>purpose</code> is set to 999.

''(p, P)'' and ''(n, N)'' are keys associated with the above path, depending on which side is performing the calculation.

''N<sub>x</sub>'' keys are the direct non-hardened children of ''N''. For instance, the path of ''N<sub>0</sub>'' from ''N'' is ''m / 0''.

===Payment Code Structure and Encoding===

* bytes <code>[0..1]</code>: address type flags (2 bytes, inclusive)
* bytes <code>[2..35]</code>: compressed public key P (33 bytes, inclusive)

Payment codes are encoded in bech32m and the human readable part is "pay" for mainnet and "payt" for testnet (all types), resulting in payment codes that look like "pay1cqqq8d29g0a7m8ghmycqk5yv24mfh3xg8ptzqcn8xz6d2tjl8ccdnfkpjl7p84".

===Address Types===

Address type flags determine which address types a payment code accepts. This is represented by big-endian ordered 16 bits. For instance, a hypothetical payment code that handles all address types will have all defined bits set to 1 (<code>0xffff</code>).

Currently defined flags:

{| class="wikitable"
! Address Type !! Flag !! Flag Value !! Ordinal Value
|-
| P2PKH || <code>1 << 0</code> || <code>0x0001</code> || 0
|-
| P2WPKH || <code>1 << 1</code> || <code>0x0002</code> || 1
|-
| P2TR || <code>1 << 2</code> || <code>0x0004</code> || 2
|}

The remaining flags are reserved for future address types.

While payment codes use 2-byte bitflag arrays, notifications use ordinal values in the form of a single byte.

===Notifications===

Notifications are performed by publishing transactions that contain a 72-byte <code>OP_RETURN</code> output. The value of the <code>OP_RETURN</code> is constructed using the following formula:

''search_key | notification_code | N<sub>x</sub> | address_type''

* ''search_key'' equals "BIP999" and is a static ASCII-encoded string (6 bytes)
* ''notification_code'' is ''H(n<sub>x</sub> * P)'' (32 bytes)
* ''N<sub>x</sub>'' is the unique public key a sender is using for a particular recipient (33 bytes)
* ''address_type'' is the '''ordinal''' value of a single address type that a sender wants to send to (1 byte). This must be selected from the recepient's accepted address types.

When Alice wants to notify Bob that he will receive future payments from her, she performs the following procedure:

# Assigns an unused, unique index ''x'' to Bob (''0'' if Bob is the first party she is notifying).
# Calculates a notification code: ''notification_code = H(n<sub>x</sub> * P)''
# Commits to one of Bob's accepted address types by choosing its ordinal value. Going forward Alice must not send to address types other than the one she committed to in the notification.
# Constructs a notification payload by concatenating the above values according to the formula.
# Selects any UTXO in her wallet, preferably not associated with her.
# Sends a transaction with a single <code>OP_RETURN</code> output whose value is set to the constructed payload.

When Bob notices an <code>OP_RETURN</code> starting with the search key, he performs the following procedure:

# Breaks down the payload into its four constituent parts.
# Discards the ''search_key'' (item #0).
# Selects ''N<sub>x</sub>'' (item #2) and performs ''H(N<sub>x</sub> * p)'' (Bob does not know the value of ''x'').
# If the above value matches the notification value (item #1), Bob found a notification addressed to himself and stores ''N<sub>x</sub>'' together with ''address_type''.
# If this process fails for any reason, Bob assumes a spurious notification or one not addressed to himself and gives up.

Since changing ''x'' yields a completely different sender identity, Alice can always re-notify Bob from a different index when she does not want to be associated with her previous identity. Alice can also re-notify Bob when she wants to start sending to a different address type. Bob must be able to update his watchlist in that case and he can stop watching addresses associated with the old address type.

===Transacting===

Alice initializes counter ''c'' which is unique to Bob and increments with each transaction. ''c'' is a 64-bit integer and must be inputted into a hasher as a big-endian encoded array of 8 bytes.

1. Alice calculates a secret point (constant between Alice and Bob):

''S = n<sub>x</sub> * P''

2. Alice calculates a shared secret:

''s = H(S | c)''

3. Alice calculates Bob's ephemeral public key and its associated address where the funds will be sent:

''P<sub>c</sub> = P + s*G''

4. Alice constructs an address using the key ''P<sub>c</sub>'', using one of the address types she committed to in the notification transaction.

Bob constructs his watchlist by mirroring this process on his end, except that his method of calculating ''S'' is:

''S = N<sub>x</sub> * p''

When Bob wants to spend from such addresses, he calculates his private keys in the following manner:

''p<sub>c</sub> = p + s''

==Appendix A: Test Vectors==

===Alice's Wallet===

'''BIP32 seed:''' 0xfe

'''Master xprv:''' xprv9s21ZrQH143K2qVytoy3eZSSuc1gfzFrkV4bgoHzYTkgge4UoNP62eV8jkHYNqddaaefpnjwkz71P5m4EW6RuQBJeP9pdfa9WBnjP6XUivG

'''n:''' xprv9xgkGJLpRhrdGVTFqS49xKyH85yUKWfkazSjWUbnaqmRf5ucc2YwruLmFwqwtZ3S3Whxgj52HoyTrtfbzDUrAseWmER9DK3TZUTorzSpkdt

'''N:''' xpub6Bg6fosiG5QvUyXiwTbAKTv1g7oxiyPbxDNLJs1Q9BJQXtEm9ZsCQhfF7CEo94MBjwEz5wBmCuo5AcSeBtKDE73GfGcQ6PATzVBVfdPtY17

'''x:''' 0

'''n<sub>x</sub>:''' 011447e7c6426aecd3fb3e76fba39ef3dc1e91dc578e8b535f714234c62675c5

'''N<sub>x</sub>:''' 039d138aaf5bc2e27a9740541576eceb90a5f20b4799dbfda48e5c7ca240505753


===Bob's Wallet===
'''BIP32 seed:''' 0xff

'''Master xprv:''' xprv9s21ZrQH143K47bRNtc26e8Gb3wkUiJ4fH3ewYgJeiGABp7vQtTKsLBzHM2fsfiK7Er6uMrWbdDwwrdcVn5TDC1T1npTFFkdEVoMgTwfVuR

'''p:''' 0x3ba93579cf5b37d18cd2e3507d51b22c3771a2dbfd1b58dd45d08a6e6ed4b965

'''P:''' 0x02943ebcb1dbb1e1cb7c0350687c2c8dbdf1c4f350d849341a6ff61a595f2085e2

'''Accepted scripts:''' 0x03 (legacy + segwit) (0x01 | 0x02)

'''Payment code:''' pay1qqps99p7hjcahv0ped7qx5rg0skgm003cne4pkzfxsdxlas6t90jpp0zpnwgqy


===Alice notifying Bob===
'''S:''' 0x0295ac9a667d7077def44b11104811e5d91d164dd60cb08275b313a33691320cb3

'''Notification code:''' 0xfbe8d683683023aaa066ba13cf79c9f8a7d3c69a4705025f3f4f4887a61eb975

'''Address type commitment:''' 1 (segwit)

'''Notification output script:''' OP_RETURN OP_PUSHBYTES_72 424950393939fbe8d683683023aaa066ba13cf79c9f8a7d3c69a4705025f3f4f4887a61eb975039d138aaf5bc2e27a9740541576eceb90a5f20b4799dbfda48e5c7ca24050575301


===Alice sending to Bob===
'''c:''' 0

'''s:''' 0xb7508ed246458221cc37d01de5d2f94be3a141180da11b78cbffdfd81a75f223

'''s*G:''' 0x03e99301fb24083590fde78473d55a8435b0aed0dad65c516dfb268586fbe134be

'''P<sub>c</sub>:''' 0x03145adc275eda50ea188250f85e729b77b22f9868d024aff00ea61d552373cbba

'''A<sub>c</sub>:''' bc1q7nmrkdgg3qq3l2ggh46zwv7750q6rjux0nx27a


===Bob spending===
'''c:''' 0

'''p<sub>c</sub>:''' 0xf2f9c44c15a0b9f3590ab36e6324ab781b12e3f40abc745611d06a46894aab88

==Appendix B: Potential OP_RUTURN Services==

Compact Block Filters, as formulated in BIP-0158, do not cover <code>OP_RETURN</code> data payloads. In support of light wallets, an external service could publish transaction proofs for all transactions that include the tagged notification payload. Light wallets would download all such transactions, filter for matches against their payment code, then verify the transaction proofs against the block headers obtained over the P2P network.

==Appendix C: Potential Notification Transaction Services==

No specific instruction is given as to the details of the notification transaction beyond simply including the single <code>OP_RETURN</code> payload. Since no restriction exists for other inputs or outputs of this transaction, there is an opportunity for an external service to include this payload in a transaction completely unrelated to Alice's wallet. Such a service could charge a fee out-of-band to help cover fees.

Another opportunity exists for an existing business to attach notification payloads to transactions sent during the normal course of operations. Large withdrawal transactions from mining pools or exchanges could include a marginal notification payload without affecting overall fees.

==Reference==
* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]
* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]
* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]
* [[bip-0157.mediawiki|BIP157 - Client Side Block Filtering]]
* [[bip-0158.mediawiki|BIP158 - Compact Block Filters for Light Clients]]

